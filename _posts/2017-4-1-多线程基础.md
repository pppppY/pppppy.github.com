---
layout: post
title:  "（四、Schema与数据类型优化）高性能MySQL读书笔记"
image: ''
description: ''

tags:
- Java
- 多线程
categories:
- Java基础
- 学习记录
---
## **1 线程的实现**
线程是比进程更轻量级的调度执行单位，线程可以将一个进程的资源分配和执行调度分开。多个线程共享进程资源（内存，文件I/O等），同时每个线程都有自己独立的方法栈和程序计数器，是CPU调度的最小单位。

线程实现方法有三种：
1. **内核线程**，直接由OS内核支持的线程，这种线程由内核来负责线程切换。程序一般使用内核线程的一种轻量级接口——轻量级进程，每个内核线程对应一个轻量级进程，轻量级进程的各种操作都需要内核线程来支持，所以需要来回在用户态和内核态进行切换。
2. **用户线程**，完全运行在用户态的线程，一个进程可以对应多个用户线程，但是线程所有操作都没有Os内核的支持，Java已经放弃使用用户线程。
3. **用户线程与轻量级线程混合**：存在大量用户线程，os提供支持的轻量级进程作为用户线程和内核线程之间的桥梁。

**JAVA线程实现**：1.2以前是基于用户线程实现，1.2之后使用OS原生线程模型实现，不同平台实现不同，在winodws和linux中使用一对一的轻量级线程实现。

## **2 线程调度方式**
1. **协同式调度**：线程执行时间由线程本身控制，实现简单，当某个线程一直不进行线程切换时，会导致整个系统奔溃。
2. **抢占式调度**：线程执行时间由系统分配，Java中可以使用yield()来让出执行时间，并且通过设置线程优先级，可以**建议**系统给某个线程多分配时间。

## **3 并发编程面临的问题**
### **3.1 CPU上下文切换**
CPU通过时间片分配算法来循环执行任务，当前任务在执行一个时间片后会切换到下一个任务，切换时CPU需要保存上一个任务的状态，以便下次再加载这个任务。任务从保存到再加载的过程称为一次上下文切换。上下文切换需要耗费时间，影响多线程的执行速度。

减少CPU上下文切换的方法：
1. 无锁并发编程（如ConcurrentHashMap，将数据分为多段，不同线程处理不同的段）
2. CAS算法，如Atomic包
3. 避免创建不需要的线程
4. 协程：在单线程里面实现多任务调度

### **3.2 死锁**
**产生条件**
1. 互斥条件：一个资源每次只能被一个进程使用。
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

**解决方法**
1. 避免一个线程同时获得多个锁
2. 避免一个线程同时占有多个资源
3. 定时锁
4. 数据库锁的加解锁要在一个数据库连接中

### **3.3 资源限制**
- 硬件资源：上传/下载带宽，硬盘读写速度和CPU处理速度
- 软件资源：数据库连接，socket连接等

## **4 Java并发底层机制**
### **4.1 java程序执行机制**
JAVA =》 Java字节码 =》 ClassLoader加载到JVM中 =》 JVM执行字节码（转化成汇编指令在CPU上执行）

### **4.2 Volatile**
可以实现共享变量的可见性， 不会引起上下文切换和调度。

volatile变量写操作会产生2个效果
1. 写线程会将线程工作内存的volatile变量回写到主内存中。
2. 使所有其他线程工作内存中该变量的值无效。


## **5 多线程基础**
OS在运行一个程序时会为其创建一个进程，在一个进程里可以创建多个线程，这些线程有各自的计数器、堆栈和局部变量等属性，能够共享的访问内存。

使用多线程优点：
1. 利用多个CPU核心
2. 实现更快的响应时间
3. 更好的多线程模型

### **5.1 线程的状态**
- NEW : 初始状态，线程被创建，未调用start方法
- RUNNABLE : 运行状态，线程已经就绪或正在运行
- BLOCKED : 阻塞状态，阻塞于锁
- WAITING : 等待状态，表示当前线程需要其他线程做出特定的动作（通知或中断）
- TIME_WAITING : 超时等待
- TERMINATED :　终止状态

![image](F:\ProjectInCV\imgnote\tst.png)

### **5.2 守护线程**
Thread.setDaemon(true) 在线程启动之前设置，Daemon线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这意味着，当一个Java虚拟机中不存在非Daemon线程的时候，Java虚拟机将会退出。

### 构造线程
Thread的init方法如下所示, 
```java
private void init(ThreadGroup g, Runnable target, String name,long stackSize,
    AccessControlContext acc) {
    if (name == null) {
    throw new NullPointerException("name cannot be null");
    }
    // 当前线程就是该线程的父线程
    Thread parent = currentThread();
    this.group = g;
    // 将daemon、priority属性设置为父线程的对应属性
    this.daemon = parent.isDaemon();
    this.priority = parent.getPriority();
    this.name = name.toCharArray();
    this.target = target;
    setPriority(priority);
    // 将父线程的InheritableThreadLocal复制过来
    if (parent.inheritableThreadLocals != null)
    this.inheritableThreadLocals=ThreadLocal.createInheritedMap(parent.
    inheritableThreadLocals);
    // 分配一个线程ID
    tid = nextThreadID();
}
```
在上述过程中，一个新构造的线程对象是由其parent线程来进行空间分配的，而child线程
继承了parent是否为Daemon、优先级和加载资源的contextClassLoader以及可继承的
ThreadLocal，同时还会分配一个唯一的ID来标识这个child线程。至此，一个能够运行的线程对
象就初始化好了，在堆内存中等待着运行。

### 中断
线程的一个标识属性，其他线程通过调用该线程的interrupt()来对其进行中断。

线程通过isInterrupted()来判断是否被中断，也可以调用Thread.interrupted()来复位中断标志位。

##### 中断与线程关闭
Java中没有一种安全的抢占式方法来停止线程。一种方法是使用一个设置一个关闭标识，线程定期查看该标识来决定是否提前结束。

如果线程有调用阻塞方法（如BlockIngQueue.take()），使用定期轮询标识位的方法可能无法结束线程。

中断可以提供这样的功能，虽然JAVA api没有规定中断是用来取消线程的，但是这是它使用的最佳实践。

### 线程间的通信(volatile/synchronized, wait/notify, piped, join, ThreadLocal)

##### volatile和synchronized
volatile关键字通过内存屏障来实现以下两个特性：
1. 对volatile变量的写会立即刷新到主内存中。
2. volatile变量的读一定会读取到主内存中最新的值。（volatile写会使其他线程工作内存中的变量值变为无效）

synchronized 本质是对一个对象的monitor进行获取，获取过程是排他的，同一时刻只能有一个线程获取到monitor。任何线程进入同步块或调用同步方法时都要先请求monitor，如果失败就进入同步队列等待，线程状态为Blocked，当拥有monitor的线程退出同步块或同步方法时，释放monitor，这时会唤醒同步队列中的线程，使其重新尝试对monitor的获取。

![image](F:\ProjectInCV\imgnote\sm.png)

synchronized最终底层是使用了os提供的互斥锁Mutex lock来实现，线程之间的上下文切换需要花费时间。JDK 1.6之后引入了轻量级锁和偏向锁来优化synchronized，另一些常见的优化是锁消除，锁粗化等。

##### 通知等待机制
- notify()/notifyAll()
- wait()

- 使用上面的方法时需要先调用对象的锁
- 调用wiat()后，线程状态由Runing变为WATTING，线程放置到对象的等待队列中。
- notify(),notifyAll()方法调用后，等待线程依旧不会返回，需要调用notify的线程释放锁之后，等待线程才有机会从wait()返回。
- notify方法会将等待线程由等待队列移动到同步队列，线程状态由WAITING变为BLOCKED。

![image](F:\ProjectInCV\imgnote\smw.png)

##### 管道
使用面向字节的PipedOutputStream/PipedInputStream或者面向字符的PipedReader/PipedWriter
```java
public class Piped {
    public static void main(String[] args) throws Exception {
        PipedWriter out = new PipedWriter();
        PipedReader in = new PipedReader();
        // 将输出流和输入流进行连接，否则在使用时会抛出IOException
        out.connect(in);
        Thread printThread = new Thread(new Print(in), "PrintThread");
        printThread.start();
        int receive = 0;
        try {
            while ((receive = System.in.read()) != -1) {
                out.write(receive);
            }
        } finally {
         out.close();
        }
    }
    static class Print implements Runnable {
        private PipedReader in;
        public Print(PipedReader in) {
            this.in = in;
        }
        public void run() {
            int receive = 0;
            try {
                while ((receive = in.read()) != -1) {
                    System.out.print((char) receive);
                }
            } catch (IOException ex) {
            }
        }
    }
}
```

##### Thread.join()
线程A执行thread.join()，A将等待thread线程终止之后才从thread.join()中返回。

##### ThreadLocal

### Lock
相对于synchronized，显示Lock提供可尝试非阻塞式的获取锁，能被中断的获取锁，超时获取锁等特性

##### 方法
- lock/lockInterruptibly/tryLock
- unlock
- newCondition

### Fork/Join 框架
通过Fork将大任务分割为小任务，通过Join来合并结果。

#### 工作窃取算法
将任务分割为多个互不依赖的子任务之后，一个线程对应一个任务队列。当线程A执行完其队列中的所有任务后，可以继续从其他线程的任务队列中窃取任务来执行。

实现上一般使用双端队列，被窃取任务线程从头取任务，窃取任务线程从尾取任务。

#### Fork/Join 设计
Fork/Join使用两个类来完成分割任务和任务结果合并
- ForkJoinTask，提供两个实现，没有返回结果的RecursiveAction和有返回结果的RecursiveTask。
- ForkJoinPool, 用来执行ForkJoinTask。

#### 使用
继承ForkJoinTask，实现compute()方法，可以在方法中判断是否还需要拆分成更小的任务。需要拆分就继续创建ForkJoinTask，并调用fork()，通过调用joing()得到子任务的结果，最后合并子任务结果返回。

在使用时，首先需要创建一个ForkJoinPool，然后将ForkJoinTask实例通过submit提交，最后通过FutreTask来阻塞等待任务的结果。

ForkJoinTask在执行时可能发生异常，可以使用isCompletedAbnormally()来判断任务是否抛出异常或被取消，并通过ForkJoinTask的getException方法来获取异常，如果任务被取消返回CancellationException,如果任务没结束或没有异常返回Null。
```java
public class AddNumTask extends RecursiveTask<Integer> {

    public static void main(String[] args) {
        ForkJoinPool pool = new ForkJoinPool();
        AddNumTask task = new AddNumTask(1, 100);
        Future<Integer> result = pool.submit(task);
        try {
            System.out.println("sum = [" + result.get() + "]");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }

    private int beg;
    private int end;

    public AddNumTask(int beg, int end) {
        this.beg = beg;
        this.end = end;
    }

    @Override
    protected Integer compute() {
        int range = end - beg;
        if(range <= 0)
            return 0;

        int sum = 0;
        if(range + 1 > 10){
            int mid = beg + (range>>1);
            AddNumTask leftTask  = new AddNumTask(beg, mid);
            AddNumTask rightTask  = new AddNumTask(mid + 1, end);

            leftTask.fork();
            rightTask.fork();

            int leftsum = leftTask.join();
            int rightsum = rightTask.join();

            sum = leftsum + rightsum;
        }else{
            for(int i = beg ; i <= end; ++ i)
                sum += i;
        }
        return sum;
    }
}
```

### 并发工具类
#### CountDownLatch
用于使一个或多个线程等待其他线程完成。

在创建CountDownLatch时给定一个count值，每当一个线程调用countDown时，count减1，当count值为0时，所有在awatit上等待的线程都会被唤醒。

#### CyclicBarrier
让一组线程到达同步点时被阻塞，直到最后一个线程到达同步点。这时所有在同步点的线程都将继续运行。

构造CyclicBarrier时通过参数parties来表示屏障拦截的线程数。

线程在运行到同步点时，就调用CyclicBarrier.await()来等待其他线程到达。

#### Semaphore
控制并发线程数，可以用做流量控制，规定最多只能有几个线程同时执行一段程序。

- acquire()/realse()
- intavailablePermits()：返回此信号量中当前可用的许可证数。
- intgetQueueLength()：返回正在等待获取许可证的线程数。
- booleanhasQueuedThreads()：是否有线程正在等待获取许可证。
- void reducePermits（int reduction）：减少reduction个许可证，是个protected方法。
- Collection getQueuedThreads()：返回所有等待获取许可证的线程集合，是个protected方
法。

#### Exchanger
用于线程间协作，两个线程通过exchange方法交换数据，一个线程调用exchange方法后会一直等待，知道另一个线程也执行exchange方法。当两个线程到达同步点时，就能交换数据。

```java
 public static void main(String[] args) {
        Exchanger<String> exchanger = new Exchanger<>();

        new Thread(() -> {
            System.out.println("A do something....");
            try {
                Thread.sleep(1500);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("A reach the exchange point..");

            try {
                String dataB = exchanger.exchange( "Data form A");
                System.out.println("A receive :" +dataB);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();


        new Thread(() -> {
            System.out.println("B do something....");

            System.out.println("B reach the exchange point..");

            try {
                String dataA = exchanger.exchange("Data form B");
                System.out.println("B receive :" + dataA);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
    }
```

### 线程池
#### 特点
##### 几种常用的线程池的工厂方法
1. Executors.newCachedThreadPool：无界，自动线程回收
2. Executors.newFixedThreadPool：固定大小的线程池
3. Executors.newSingleThreadExecutor：只有一个线程
##### 配置参数
- **corePoolSize/maximumPoolSize**
    
    当新任务提交时，当前线程池运行线程数为x
    
    - x < corePoolSize : 会创建一个新线程来处理这个任务（就算有其他线程是闲置的）。
    - corePoolSize < x < maximumPoolSize : 如果队列没满就入队，否则新建一个线程来执行该任务。
    
    当coorePoolSize == maximumPoolSize时，就是一个固定大小的线程池，如果maximumPoolSize设为Integer.MAX_VALU, 就是一个无界的线程池。一般这两个参数在构造函数中设置，也可以通过set方法更改。

- **prestartCoreThread与prestartAllCoreThreads**
    
    通常，core线程会在任务到来的时候才初始化，但是可以通过覆盖prestartCoreThread与prestartAllCoreThreads方法来实现特殊的初始化逻辑，比如开始就队列中就存在任务。

- **ThreadFactory**

    新线程通过ThreadFactory创建，默认使用 Executors#defaultThreadFactory，所有线程都在一个线程组，优先级为NORM_PRIOPITY，非守护线程。

- **Keep-alive**

    如果当前池中包含大于corePoolSize的线程，空闲keepAliveTime的线程将被回收。可以通过构造函数参数指定，也可以使用set方法动态更改。一般情况，线程回收只在线程数大于corePoolSize时有效，可以通过allowCoreThreadTimeOut(boolean)来使超时策略也能应用在core线程上。

- **队列**

    任何BlockingQueue都可能用来保存和传递任务，队列的用途受pool sizing的影响，假设当前有x线程在运行
    
    - x < corePoolSize：线程池永远会新建线程，而不是将任务入队。
    - x >= corePoolSize: 线程池总会优先将任务入队，只有当队列满了的情况下，才会创建信息线程。
    - 如果入队失败且x > maximumPoolSize，那么任务将被拒绝。

    队列的选择
    
    - 直接传递：**SynchronousQueue**，不在将任务排队，而是直接交付任务，如果需要对任务排队时，之间新建线程来执行任务。可以避免一系列存在依赖的任务都在队列中带来的死锁或饥饿现象，需要无界的maximumPoolSize来避免发生拒绝提交的任务。当任务处理速度慢于任务产生速度时，池中的线程总数将一直增加。
    - 有界队列：队列的大小和线程池大小之间需要做平衡。大队列和小池可以减少CPU，OS资源占用和上下文切换的消耗，但是会导致低吞吐率。大量的任务会在队列中阻塞。小队列大池可以使CPU一直忙碌，但是可能导致线程调度消耗过大，减低吞吐量。

- **被拒绝的任务**

    当线程池关闭或者达到上限时，提交的任务会被拒绝，execute方法会去执行 RejectedExecutionHandler#rejectedExecution方法来处理被拒绝的任务。有四种已经定义好的handler:
    
    1. ThreadPoolExecutor.AbortPolicy：默认策略，抛出RejectedExecutionException
    2. ThreadPoolExecutor.CallerRunsPolicy：执行execute方法的线程来运行任务
    3. ThreadPoolExecutor.DiscardPolicy: 直接丢弃被拒绝的任务
    4. ThreadPoolExecutor.DiscardOldestPolicy：如果线程池未关闭，移除任务队列中的首元素，重新尝试提交执行该任务（可能再次失败）

- **Hook 方法**

    提供beforeExecute和fterExecute
    
- **getQueue**

    使用这个方法可以得到工作任务队列，一般用来检测和调试。
    
- **Finalization**

    如果一个线程池不再被程序引用并不再包含线程时会被自动shutdown，如果想让一个线程池就算忘记调用shutdown也能自动被回收，需要保证所有的空闲线程都死亡，这可以通过设定合理的keep-alive时间，将corePoolSize设置为0，或者设置allowCoreThreadTimeOut(boolean)赖世雄。


#### 处理流程


![image](F:\ProjectInCV\imgnote\tpl.png)

如上图，线程池excute()方法执行流程如下：
1. 当前池中运行线程少于corePoolSIze，则创建新线程来执行任务。
2. 否则，将任务加入阻塞队列。
3. 如果队列已满，创建新线程来执行任务。
4. 如果创建新任务将使当前运行线程数超过maximunPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法来处理任务。

#### 使用
- 新建：Exceutors的工厂方法/ThreadExceotrs构造方法
- 提交任务：execute提交没有返回结果的任务，submit()提交需要返回值的任务，返回一个future对象。
- 关闭：原理是遍历所有工作线程，调用线程的interrupt方法来中断它们。只有响应中断的线程才能停止。
    - shutDownNow:强线程池设置为STOP状态，尝试停止所有正在执行或暂停任务的线程，返回等待执行任务的列表。
    - shutDown：将线程池状态设置为SHUTDOWN，中断没有执行任务的线程。
- **合理配置线程池**
    
    分析任务特性：CPU密集，IO密集和混合型

    性质不同的任务应该使用规模不同的线程池分开处理。CPU密集型任务应该配置较小的线程（Ncpu + 1），IO密集型任务线程可能会有大部分时间在等待IO，所以可以配置大竟可能多的线程数（Ncpu * 2）。混合型任务，并且拆分后2个任务运行时间相差不大，就可以拆分任务。
    
    处理带优先级的任务可以使用PriorityBlockingQueue来处理。
    
    依赖其他资源的任务（如数据库连接池），可以加大线程数。
    
    尽量使用有界队列，确保系统的稳定和预警能力。

#### 实现原理简述
- 状态
    
    ThreadPoolExecutor使用一个AtomicInteger的原子变量ctl保持状态，这个integer类型的状态分为两部分：workCount和runState。workCount用来记录当前线程池在运行的线程数，runState有如下几种：
    
    - RUNNING：接收新任务或在执行队列中的任务
    - SHUTDOWN：不再接收新任务，但是还会执行队列中的任务
    - STOP：不再接收新任务和执行队列中的任务，会中断当前执行的任务。
    - TIDYING：所有任务停止，workCount为0，所有线程将调整TIDYING状态，将要运行terminated()方法。
    - TERMINATED：terminated()方法运行结束。

- 每个线程在Executor中用Worker实例来表示，Worker继承了AbstractQueuedSynchronizer，并保存一个Thread对象，这个Thread的对象在调用Worker的构造方法时，通过ThreadFactory创建。
- 在ThreadPoolExecutor，使用HashSet来保存Worker，使用BlockingQueue来保存提交的任务
- execute()方法
```java
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    /*
     * Proceed in 3 steps:
     *
     * 1. If fewer than corePoolSize threads are running, try to
     * start a new thread with the given command as its first
     * task.  The call to addWorker atomically checks runState and
     * workerCount, and so prevents false alarms that would add
     * threads when it shouldn't, by returning false.
     *
     * 2. If a task can be successfully queued, then we still need
     * to double-check whether we should have added a thread
     * (because existing ones died since last checking) or that
     * the pool shut down since entry into this method. So we
     * recheck state and if necessary roll back the enqueuing if
     * stopped, or start a new thread if there are none.
     *
     * 3. If we cannot queue task, then we try to add a new
     * thread.  If it fails, we know we are shut down or saturated
     * and so reject the task.
     */
    // 得到当前在运行的work数目，如果<corePoolSize，尝试新建一个Worker来执行任务
    int c = ctl.get();
    if (workerCountOf(c) < corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    // 查看线程池是否处于running状态，并且尝试向队列添加任务
    if (isRunning(c) && workQueue.offer(command)) {
        // 添加成功，再次检查线程池的状态
        int recheck = ctl.get();
        if (! isRunning(recheck) && remove(command))
            reject(command); // 如果不处于running，并且无法从队列中移除任务，拒绝任务
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false); // 如果当前运行的worker位0，添加一个新的worker来运行任务
    }
    else if (!addWorker(command, false)) // 队列已满，尝试直接新建Worker来运行任务
        reject(command); // 新建Worker失败，拒绝任务
}

```