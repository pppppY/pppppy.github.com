---
layout: post
title:  "（四、Schema与数据类型优化）高性能MySQL读书笔记"
image: ''
description: ''

tags:
- 高性能MySQL
- 读书笔记
categories:
- 数据库
- 学习记录
---
## **1 选择优化的数据类型**
一般原则：
1. 更小的数据类型。
2. 简单的数据类型，如整型比字符操作代价低。
3. 避免NULL，NULL值使索引、索引统计和值比较变得更复杂，一般需要建索引的列要设置成not null。


### **1.1 整数类型**

包含TINYINT,SMALLINT,MEDIUMINT,INT,BIGINT这几种，分别占用8,16,24,32,64位的存储空间。在声明后面指定宽度（如INT(2)）只是改变显示时的位数，不影响存储和计算。

### **1.2 实数类型**

FLOAT和DOUBLE支持标准的浮点数运算进行近似运算。

DECIMAL存储精确的小数。

### **1.3 字符串类型**

- **VARCHAR和CHAR**
    - **VARCHAR**存储可变长字符串，比定长字符串也节省空间。适合于最大长度远远大于平均长度，并且更新很少的列，因为在UPDATE时，VARCHAR可能带来额外的开销。在InnoDB引擎中，可以使用BLOB存储过长的VARCHAR。**在5.0版本之后，不会截断末尾的空格。**
    - **CHAR**：定长，总是被分配足够的空间。**适合短字符串。会截断末尾的空格**。

- **BLOB和TEXT**（为存储大字符串设计）

    - **BOLB**属于二进制类型，包括TINYBLOB,SMALLBLOB,BLOB,MEDIUMBLOB,LONGBLOB等。BLOB没有排序规则和字符集。
    - **TEXT**属于字符类型，同样有类似的一系列TEXT类型。TEXT有排序规则和字符集。
    
    对BLOB或TEXT列排序时，只根据前max_sort_length个字节进行排序。MYSQL也不能使用两个类型全部长度的字符串进行索引。

### **1.4 日期和时间类型**

- **DATETIME**：保存大范围值（1001-9999），精度为秒，格式为YYYYMMDD，与时区无关，8字节存储。
- **TIMESTAMP**：1970年开1月1日依赖的秒数，与UNIX时间戳相同。

### **1.5 位数据表示**

- **BIT**：在一列中存储多个ture/false值，最大长度为64。MYSQL将BIT当做字符串，比如b'00111001'（二进制值等于57），查询出来的值是字符'9'（ASCII码57是字符'9'），而不是57。这容易让人困惑，尽量不适用BIT。
- **SET**

### **1.6 identifier**

选择标识符很重要，一般的原则：
1. 尽量使用整数类型
2. 不要使用ENUM和SET
3. 避免使用字符类型

## **2 MySQL schema设计中的陷阱**
- **过多的列**：存储引擎API工作时需要在服务器层和存储引擎层之间通过缓冲格式来拷贝数据，然后在服务器层将缓冲内容解码成各个列。这个解码过程代价很高，且与列的数目相关。
- **过多的关联**：关联越多，解析和查询优化的代价越大，一般单个查询的关联最好在12个表以内，才可能保持查询执行得快速且并发。
- **过度使用枚举**
- **在合适的时候使用枚举**
- **在合适的时候使用NULL**

## **3 范式和反范式**

### **3.1 范式**

- **第一范式**：列的原子性，数据库中每列都不可再分。
- **第二范式**：满足第一范式，并且表中必须要主键，并且所有的其他列都必须依赖于主键，比如订单表（商品ID，订单ID，单价，数量，折扣），其中（商品ID，订单ID）是主键，数量和折扣完全依赖于主键，符合第二范式，但是单价列只依赖于商品ID，不符合第二范式。

    违反第二范式容易造成数据冗余。
- **第三范式**：满足第二范式，非主键必须直接依赖主键，不能存在传递依赖。

    考虑一个订单表【Order】（OrderID，OrderDate，CustomerID，CustomerName，CustomerAddr，CustomerCity）主键是（OrderID）。 
其中 OrderDate，CustomerID，CustomerName，CustomerAddr，CustomerCity 等非主键列都完全依赖于主键（OrderID），所以符合 2NF。不过问题是 CustomerName，CustomerAddr，CustomerCity 直接依赖的是 CustomerID（非主键列），而不是直接依赖于主键，它是通过传递才依赖于主键，所以不符合 3NF。 
通过拆分【Order】为【Order】（OrderID，OrderDate，CustomerID）和【Customer】（CustomerID，CustomerName，CustomerAddr，CustomerCity）从而达到 3NF。

### **3.2 范式的优缺点**

优点：
- 范式化的更新操作一般快于反范式化。
- 数据较好的范式化时，只存在很少或没有冗余的数据，所以只需要修改更少的数据。
- 范式化的表更小，更容易存储到内存，执行操作更快。
- 没有冗余数据也意味着需要更少的使用distinct或group by。

缺点：范式化的schema在查询时需要大量的关联，容易引起一些索引失效，查询代价高。

### **3.3 反范式的优缺点**

优点：
- 查询需要更少的关联，大部分查询即使在没有索引的情况下也是扫描全表。当数据比内存大时可能比使用关联块很多。
- 单独的表更有利于索引策略。

缺点：数据冗余，对冗余数据的更新复杂。

#### 混用范式和反范式
可以混合使用两种模式，比如在不同的表中存储相同的列，并使用触发器来更新各列（MySQL 5.0之后支持）。


## **4 缓存表和汇总表**
创建一张完全独立的汇总表或缓存表有时能够提升性能。

一个例子就是统计24小时内，网站发送的消息数。实时维护一个计数器是不现实的。可以设置定时任务，可以使用一个汇总表，每小时向汇总表中插入一条记录，统计上一小时发送的消息数。每次查询24小时内发送的消息数时，从汇总表取出所有满足要求的记录，并合并。这样的方法可能得到的计数是不准确的。

**影子表**：为了保证重建汇总表或缓存表时，数据依然可用。可以使用影子表。首先新建一张和原表结果相同的影子表，然后复制所有数据到影子表。
```sql
create table my_summary_new like my_summary
```
然后，重命名影子表和原表，被重命名的原表可以作为历史记录，实现快速回滚。
```sql
rename table my_summary to my_summary_old,  my_summary_new to my_summary
```
### **4.1 视图**
视图即是虚拟表，也称为派生表，因为它们的内容都派生自其它表的查询结果。虽然视图看起来感觉和基本表一样，但是它们不是基本表。基本表的内容是持久的，而视图的内容是在使用过程中动态产生的。

### **4.2 计数器表**
一个典型的例子就是网站访问计数。如果直接在应用表中保存计数器，在更新时会出现并发问题。可以在一个表中加入100行数据，每次更新计数器时就从随机选择100行中的某行更新，这样就可以让更多的计数更新并发的执行。当要统计访问量时，就将100行的计数加起来就可以了。

**为了提升查询速度，经常会加入额外的索引和冗余列，甚至创建缓存表和汇总表。这些优化读性能的方式一般都是以牺牲写性能为代价。有时候不但写性能变差，写和读的方式也变的复杂**

## **5 Alter table操作的速度**
MySQL Alter TABLE操作的代价很高，MySQL大部分修改表结构操作的方法是用新的结构创建表，然后从旧表查所有数据并插入新表，然后删除旧表。这样的操作非常消耗时间。

