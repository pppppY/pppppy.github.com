---
layout: post
title:  "代码高亮测试"
image: ''
tags:
- 测试
description: '这是用来测试的标签'
categories:
- 测试Tag2
---
### 303. Range Sum Query - Immutable
##### 题意
给定一组无序整型数组A，求给定范围[i, j]内的所有元素的和。
##### 解法 
**维护一个前i项和的数组**X，X[i]表示数组A[0 ,i]范围内元素的和，**sum[i, j] = X[j] - X[ i - 1]** ,**需要注意i为0时的情况，可以让X长度为A.length + 1**。

### 304. Range Sum Query 2D - Immutable
##### 题意
给定一个二维矩阵，求r1, c1, r2, c2组成的矩形内所有元素之和。
##### 解法
和303类似，维护一个二维数组sum，sum[i, j]表示(0, i, 0, j)这个矩形内元素之和。

建立矩阵代码如下：
```java
sum = new int[rl + 1][cl + 1]; // rl，cl表示矩阵高度和宽度
for(int i = 1 ; i <= rl ; ++ i){
    for(int j = 1 ; j <= cl ; ++ j){
        sum[i][j] = matrix[i - 1][j - 1] + sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1];
    }
}
```
计算(row1, col1, row2, col2)内元素之和代码如下：
```java
public int sumRegion(int row1, int col1, int row2, int col2) {
    return sum[row2 + 1][col2 + 1] - sum[row2 + 1][col1] - sum[row1][col2 + 1] + sum[row1][col1];
}
```
---

### 53. Maximum Subarray
##### 题意
给定无序数组nums，求元素和最大的子数组。
##### 解法
贪心，遍历数组，维护一个整型sumpre，遍历到i时，sumpre就表示表示nums[0, i-1]中的某个子数组的元素之和。
```java
public int maxSubArray(int[] nums) {
    if(nums == null || nums.length == 0)
        return 0;
    int max = Integer.MIN_VALUE;
    int left = 0;
    for(int i = 0 ; i < nums.length ; ++ i){
        left += nums[i];
        if(left > max)
                max = left;
                
        if(left < 0)
            left = 0;
    }
    return max;
}
```

### 152. Maximum Product Subarray
##### 题意
给定无序整型数组nums，求乘积最大的子元素之和。
##### 解法
由于是整型数组，所以不可能出现乘某个元素之后，乘积绝对值变小。为了记录可能出现的负负得正的情况，需要记录每次乘积的最大值和最小值，这样就能保证每次乘一个数，都能得到最大的乘积。可以得到如下的递归解：
```java
min[i] = Math.min(Math.min(nums[i] * min[i - 1], nums[i] * max[i - 1]), nums[i]);
max[i] = Math.max(Math.max(nums[i] * min[i - 1], nums[i] * max[i - 1]), nums[i]);
```
可以看到max[i]和min[i]只依赖于max[i - 1]和min[i -1]，可以只使用两个int变量来记录上次乘积的最大和最小值就可以了。
```java
    public int maxProduct(int[] nums) {
        if(nums == null || nums.length == 0)
            return 0;
        int maxPre = nums[0];
        int minPre = nums[0];
        int maxSofar = nums[0];
        for(int i = 1 ; i <nums.length ; ++ i){
            int minHere = Math.min(Math.min(nums[i] * minPre, nums[i] * maxPre), nums[i]);
            
            int maxHere = Math.max(Math.max(nums[i] * minPre, nums[i] * maxPre), nums[i]);
            
            if(maxSofar < maxHere)
                maxSofar = maxHere;
            
            maxPre = maxHere;
            minPre = minHere;
            
        }
        return maxSofar;
        
    }
```

### 121. Best Time to Buy and Sell Stock
##### 题意
给定一组无序数组代表股票当天的价格，规定一次交易分为买入和卖出两阶段，求一次交易能获得的最大收益。
##### 解法
遍历数组，记录最小的价格minPrice作为买入价格，然后计算当前价格prices[i]-minPrice，就得到在第i天卖出物品能得到的最大收益（第i天之前已经以最小价格minPrice买入了物品）。

```java
public int maxProfit(int[] prices) {
    int minPrice = Integer.MAX_VALUE;
    int profit = 0;
    for(int i = 0 ; i < prices.length ; ++ i){
        minPrice = Math.min(minPrice, prices[i]);
        profit = Math.max(prices[i] - minPrice, profit);
    }
    return profit;
}
```

### 122. Best Time to Buy and Sell Stock II
##### 题意
给定一组无序数组代表股票当天的价格，规定一次交易分为买入和卖出两阶段，求进行任意次交易能获得的最大收益（每次交易必须完成，才能开始下一次交易）。
##### 解法
可以将数组划分为递增序的多个子段，比如[7, 2, 4, 5, 7, 2, 3, 4]，可以划分为[7],[2,4,5,7],[2, 3, 4]三段，每段对应一次交易就是能获得的最大收益。上面的数组最大收益就是进行2次交易，最终收益为0 + （7 - 2） + （4 - 2） = 5，第一段只有一天，只能买入并卖出才能保证收益为0，不然收益为负。代码如下：
```java
public int maxProfit(int[] prices) {
    if(prices == null || prices.length == 0)
        return 0;
        
    int minPrice = prices[0];
    int profit = 0;
    for(int i = 1 ; i < prices.length ; ++ i){
            
        if(prices[i] < prices[i - 1]){
            profit += prices[i - 1] - minPrice;
                minPrice = prices[i];
        }
        
        if(prices[i] < minPrice)
            minPrice = prices[i];
    }
    if(prices[prices.length - 1] > minPrice)
        profit += prices[prices.length - 1] - minPrice;
    return profit;
}
```
更进一步，可以发现对于每一段，如[2, 4, 5, 7]，（7-2）= （7 - 5）+ （5 - 4） + （4 - 2），所以代码可以简化成：
```java
int profit = 0;
for(int i = 1 ; i < prices.length ; ++ i){
    if(prices[i - 1] < prices[i])
        profit += prices[i] - prices[i - 1];
}
```
### 123. Best Time to Buy and Sell Stock III
##### 题意
给定一组无序数组代表股票当天的价格，规定一次交易分为买入和卖出两阶段，求最多进行二次交易能获得的最大收益（每次交易必须完成，才能开始下一次交易）。
##### 解法
使用4个变量来记录4种状态能得到的最大收益：
- profits[0]:第i天，买入一个物品的收益
- profits[1]:第i天，买入一个物品并卖出一个物品的收益
- profits[2]:第i天，买入二个物品卖出一个物品的收益
- profits[3]:第i天，买入二个物品并卖出二个物品的收益

可以得到如下的转移方程：
```java
profits[3] = Math.max(profits[2] + prices[i], profits[3]);
profits[2] = Math.max(profits[1] - prices[i], profits[2]);
profits[1] = Math.max(profits[0] + prices[i], profits[1]);
profits[0] = Math.max(- prices[i], profits[0]);
```
代码如下：
```java
public int maxProfit(int[] prices) {
    int []profits = new int [4]; // 0 : buy one, 1: buy one sell one, 2: buy two sell one , 3 : but two sell two
    profits[0] = profits[2] = Integer.MIN_VALUE;
    
    for(int i = 0 ; i < prices.length ; ++ i){
        profits[3] = Math.max(profits[2] + prices[i], profits[3]);
        profits[2] = Math.max(profits[1] - prices[i], profits[2]);
        profits[1] = Math.max(profits[0] + prices[i], profits[1]);
        profits[0] = Math.max(- prices[i], profits[0]);
    }
    return Math.max(profits[1], profits[3]);
}
```
### 188. Best Time to Buy and Sell Stock IV
##### 题意
给定一组无序数组代表股票当天的价格，规定一次交易分为买入和卖出两阶段，求最多进行k次交易能获得的最大收益（每次交易必须完成，才能开始下一次交易）。
##### 解法
123的扩展，想法类似，使用k*2个状态记录各种交易状态。

 - profits[0][i] 表示买i-1 并卖出i-2个物品的收益。
 - profits[1][i] 表示买i-1 并卖出 i-1 个物品的收益。
 
可以得到类似的转移方程：
```java
for(int i = 0 ; i < prices.length ; ++ i){
    for(int j = k - 1; j >= 0 ; --j){
        profits[1][j] = Math.max(profits[0][j] + prices[i], profits[1][j]);
        if(j != 0)
            profits[0][j] = Math.max(profits[1][j - 1] - prices[i], profits[0][j]);
        else 
            profits[0][j] = Math.max(-prices[i], profits[0][j]);
    }
}
```
值得注意的是，刚开始可以判断k > prices.length， 如果大于，相当于能进行任意次的交易（因为prices最多能k/2次有收益的交易）。这样问题就退化成了122。

---
### 486. Predict the Winner
##### 题意
给定一个正数数组代表物品的价值，A,B两人每次从数组头部或尾部取走一个物品，每次他们都会选择最佳的策略来使自己最终获得的物品价值更高。求A是否能获胜，A,B最后取得物品的价值各是多少。
##### 解法
sum[i] 代表物品[0, i]的总价值。

maxValue[i][j] 代表从物品[i,j]开始取物品，先取物品的人能获得的最大价值。

可以得到转移方程：
```java
maxValue[i][j] = max(nums[i] + sum[j] - sum[i - 1] - maxValue[i + 1][j],
                     nums[j] + sum[j - 1] - sum[i - 1] - maxValue[i][j - 1])
maxValue[i][i] = nums[i]
```
于是得到如下解法：
```java
public boolean PredictTheWinner(int[] nums) {
    if(nums == null || nums.length == 0)
        return true;
    int len = nums.length;
    int [] sum = new int[len];
    int [][] maxValue = new int[len][len];
    sum[0] = nums[0];
    for(int i = 1 ; i < len ; ++ i)
        sum[i] = sum[i - 1] + nums[i];
    for(int i = 0 ; i < len ; ++ i)
        maxValue[i][i] = nums[i];
    for(int step = 1; step < len ; ++ step){
        for(int beg = 0; beg < len - step; ++ beg){
            int end = beg + step;
            maxValue[beg][beg + step] = Math.max(nums[beg] + getSum(sum, beg + 1, end) - maxValue[beg + 1][end],
                                                 nums[end] + getSum(sum, beg, end - 1) - maxValue[beg][end - 1]);
        }
    }
    return maxValue[0][len - 1] >= sum[len - 1] - maxValue[0][len - 1];
}
  
private int getSum(int [] sum, int i , int j){
    int leftSum = i - 1 >=0 ? sum[i - 1] : 0;
    return sum[j] - leftSum;
}
```
---
### 64. Minimum Path Sum
##### 题意
给定一个n*m的只包含非负数的矩阵，求从(0,0)走到(n-1, m-1)的路径中和最小的一条的路径。
##### 解法
令minPathSum[i][j]表示从(i,j)到(n-1,m-1)的路径，可以得到转移方程
```java
minPathSum[i][j] = grid[i][j] + min(minPathSum[i + 1][j], minPathSum[i][j + 1]) 

```
因为每次的状态(i, j)只依赖(i + 1, j)和(i , j + 1)，可以只使用一维数组来记录路径和。
```java
public int minPathSum(int[][] grid) {
    if(grid == null || grid.length == 0)
        return 0;
    int r = grid.length;
    int c = grid[0].length;
    int [] minPathSum = new int[grid[0].length];
    minPathSum[c - 1] = grid[r - 1][c - 1];
    for(int i = c - 2 ; i >= 0 ; -- i){
        minPathSum[i] = minPathSum[i + 1]  + grid[r - 1][i];
    }
    for(int i = r - 2 ; i >= 0 ; -- i){
        minPathSum[c - 1] += grid[i][c - 1];
        for(int j = c- 2; j >= 0; -- j){
            minPathSum[j] = grid[i][j] + Math.min(minPathSum[j], minPathSum[j + 1]);
        }
    }
    return minPathSum[0];
}
```

### 357. Count Numbers with Unique Digits
##### 题意
给定位数n，求[0,10^n)范围内有多少个每位都不重复的数。
##### 解法
1. 回溯,记录当前数的位数和已经使用了的数，确定满足要求的数。
    ```java
    public int countNumbersWithUniqueDigits(int n) {
        if(n <= 0) return 1;
        int cn = 1;
        boolean []mask = new boolean[10];
        for(int i = 1 ; i < 10 ; ++ i){
            mask[i] = true;
            cn += doCount(n, 0, mask);
            mask[i] = false;
        }
        return cn;
    }
    public int doCount( int n, int step, boolean[] mask){
        if(step >= n)
            return 0;
        
        int cn = 1;
        for(int i = 0 ; i < 10 ; ++ i){
            if(!mask[i]){
                mask[i] = true;
                cn += doCount(n, step + 1, mask);
                mask[i] = false;
            }
        }
        return cn;
    }
    ```
2. 令f(i)为位数为i时，每位不重复的数的总个数，则有
    ```java
    f(1) = 1 + 9
    f(2) = 1 + 9 * 9
    f(3) = 1 + 9 * 9 + 9 * 9 * 8
    ...
    
    ```
    
    可以得出动态转移方程为：
    ```java
    f(1) = 10
    t(1) = 9
    
    t(i) = t(i - 1) * (11 - i)
    f(i) = f(i - 1) + t(i)
    
    ```
---
### 516. Longest Palindromic Subsequence
##### 题意
给定一个字符串s，求最长回文子序列
##### 解法
```java
 if(s.charAt(i) == s.charAt(j)){
    dp[i][j] = dp[i + 1][j - 1] + 2;
　}
　dp[i][j] = Math.max(dp[i][j], Math.max(dp[i + 1][j], dp[i][j - 1]));
```

**答案构造**

```java
LinkedList<Character> subSeq = new LinkedList<>();
    int r = 0;
    int c = len - 1;
    while(r <= c){
        if(s.charAt(r) == s.charAt(c)){
            subSeq.addFirst(s.charAt(r));
            r ++;
            c --;
        }else {
            if(dp[r][c] == dp[r + 1][c]){
                r ++;
            }else{
                c --;
            }
        }
    }
```
### 91. Decode Ways
##### 题意
给定一串数字，1~26分别对应'A'~'Z'，求一共可以构成多少种字母字符串。
##### 解法
需要注意某些无法构成任何字母串的情况：
- **s[0] <= '0' || s[0] > '9'**
- s[i] < '0' || s[i] > '9'
- s[i] == '0' && (s[i - 1] <= '0' || s[i - 1] > '2')

num[i]表示s[0~i]能表示的字母串个数，状态转移方程为：
```java
if((s[i - 1] == '1') || (s[i - 1] == '2' && s[i] >= 0 && s[i] <= 6))
    num[i] = num[i - 2] + num[i - 1];
else if(s[i] != '0') num[i] = nums[i - 1];
```
