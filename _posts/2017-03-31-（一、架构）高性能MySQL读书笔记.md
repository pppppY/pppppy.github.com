---
layout: post
title:  "（一、架构）高性能MySQL读书笔记"
image: ''
description: ''

tags:
- 高性能MySQL
- 读书笔记
categories:
- 数据库
- 学习记录
---

## **1 逻辑架构**
Mysql逻辑架构可以分为三层：
- 最上层是处理客户端请求的服务层，包括连接处理、授权认证、安全的功能。
- 第二层是核心服务层，包括查询解析、分析、优化以及一些内置函数，所有跨存储引擎的功能都是在这一层实现：如触发器、存储过程、视图等。
- 第三层包含了不同的存储引擎，负者MySQL中数据的存储和读取。

![image](\images\msa.png)

### **1.2 连接管理与安全性**
每个客户端链接在服务器进程中对应一个线程，这个连接的查询只会在单个线程中执行。服务器可以缓存线程，对于一个连接可能不需要创建或销毁线程。

在客户端连接到MySQL服务器是会进行安全认证。

### **1.2 优化和执行**
MySQL会解析查询并创建内部数据结构（解析树），然后对其进行各种优化，如重写查询、决定表读取顺序、选择合适的索引等。

优化器不关心底层使用什么存储引擎，但是存储引擎会提供优化所需要的信息（如容量，某个操作具体开销，特殊索引等）。

select语句的结果可能被服务器缓存，在执行select前，服务器会先查询缓存。如果缓存中存在结果，就不会继续查询解析、优化和执行等步骤。

## **2 并发控制**

### **2.1 读写锁**
在处理并发读写时，为读操作加共享的读锁，写操作加排他的写锁。保证并发读写的安全性。锁管理大部分时间对MySQL用户是透明的

### **2.2 锁粒度**
为了更高效的并发，可以只锁定需要修改部分的数据。锁定数据越少，并发的程度越高。

但是加解锁也需要耗费资源，锁粒度过细也会严重影响性能。

每种MySQL引擎都可以实现自己的锁策略和锁粒度。

MySQL中一般由两种锁策略:
- 表锁：在用户对表进行写操作时需要获取到表对应的写锁，然后锁定整张表。MySQL服务器会使用表锁来实现一些功能，如Alter table语句会使用表锁，而忽略存储引擎的锁机制。
- 行级锁：最大程度支持并发，但是带来了最大的锁开销。行锁只在存储引擎层实现，InnoDB引擎支持行锁。

## **3 事务**

### **3.1 ACID特性**

1. 原子性：事务的所有操作要么全部执行，要么都不执行。
2. 一致性：数据库在执行事务之前和执行事务之后都保持在一致的状态上。
3. 隔离性：各个事务之间独立执行，互不影响。
4. 持久性：事务对数据库的改变是永久的。

### **3.2 隔离级别**
1. 可串行化：事务一个接一个执行，可以避免幻读。
2. 可重复读：所有被select选取的数据都不能被修改，保证一个事务读取的数据前后不一致。但是无法避免幻读，因为不可以修改数据，但是可以添加数据。
3. 读已提交：事务读取的数据可以被其他事务修改，会导致不可重复读。
4. 读未提交：允许其他事务看到没有提交的数据，会导致脏读。

### **3.3 可能出现的问题**
- 脏读：一个事务对数据的修改还没有提交就能被别的事务看见。
- 不可重复读：在一个事务中，多次读取同一个数据得到的结果不一样，这可能是因为别的事务修改了这个数据。
- 幻读：事务不是独立执行时发生的现象，如一个事务查找出所有男生，并将他们的年龄加1。当处理修改男生年龄的事务执行的时候，另一个事务又插入了新的男生数据，这时候就会存在第一个事务没有处理的男生数据。这种情况就称为幻读。


### **3.4 自动提交**

MySQL默认使用自动提交模式，如果不显示开始一个事务，每一个查询语句被看做一次事务。

**不同存储引擎对事务的影响**

MySQL不在服务器层管理事务，事务的实现交给存储引擎，一些存储引擎支持事务，如InnoDB，还有一些不支持，如MyISAM。

在事务中混合使用多种存储引擎会造成混乱，在一个事务中，对非事务型的表的操作将无法回滚。

### **3.5 隐式锁定**

InnoDB使用两阶段锁协定，在事务执行过程中任何时候都能加锁，并在commit或rollBack之后统一解锁。并且，InnoDB会根据事务隔离级别在需要时自动加锁，不需要显示加锁。

**在使用InnoDB是不要显示加锁，这样严重影响性能，而且容易造成死锁**。

## **4 多版本并发控制**

MySQL通过保存数据在某个时间点的快照来实现事务。根据事务开始时间的不同，每个事务对同一张表，同一时刻看到的数据可能不一致。MVCC的实现方式典型的有两种：乐观并发控制和悲观并发控制。

InnoDB通过为每行记录保存两个隐藏的列来实现MVVC，一行保存行创建时间，一行为删除时间。这两列存储的是系统的版本号，每开始一个事务，系统版本号就增加。事务开始时刻的版本号会作为事务的版本号存入创建时间列中。在可重复读隔离级别下，MVVC实现如下：
- Select

    InnoDB会根据以下条件来查找记录    
    - 只检查版本号早于当前事务版本的数据行（创建时间列小于或等于当前事务版本号的数据行），这样来确保事务读取的行都是在事务开始之前已经存在或是事务自己插入或修改的行。
    -  每行删除时间列要么未定义，要么大于当前版本号。这可以确保事务读取到的行，在事务开始之前未被删除。
    
    只有满足上面两个条件的记录，才会被查询。
    
- Insert
    
    将新插入的数据行的创建时间列设为当前系统版本号

- DELETE
    
    将删除时间列保存为当前系统版本号

- upodate
    
    插入新的数据行，将创建时间设置为当前系统版本号，将原数据行的删除时间列设为当前系统版本号。

**MVCC只在读已提交和可重复读两个隔离级别有效**

## **5 MySQL存储引擎**

### **5.1 InnoDB**
默认的事务型引擎，提供事务、高性能和自动崩溃恢复机制。一般优先考虑使用这个存储引擎。

InnoDB使用MVCC来支持高并发，实现了四个标准隔离级别，默认为可重复读级别，使用next-key locking来防止幻读。

基于聚簇索引建立，对主键查询性能高，但是所有非主键索引都需要包含主键。主键不能太大，否则所有索引都会很大。

InnoDB可以实现热备份。

### **5.2 MyISAM**
不支持事务和行级锁，奔溃后无法安全恢复。提供全文索引、压缩、空间函数等特性。

MyISAM 对表加锁，读取时加读锁，写入时加写锁，读表时可以并发插入。

MyISAM可以对数据进行压缩，来减少I/O.

### **5.3 Archive**
只支持insert和select操作，会缓存所有的写，并对插入进行压缩，比MyISAM需要更少的磁盘IO。每次select需要扫描全表，适合日志和数据采集类应用。

### **5.4 Memory**
所有数据保存在内存，数据修改少，重启后表结构保存，但是数据全表丢失。支持Hash索引。应用场景有：
- 用于lookup表或mapping表
- 缓存周期性聚合数据的结果
- 保存数据分析产生的中间结果

Memory是表级锁，并发写入性能低。
### **5.5 存储引擎的选择**

一般考量几个点：事务、备份、奔溃恢复和特有特性

举例：

- 日志性应用：日志应用需要快速的插入性能，可以使用MyISAM作为存储引擎。如果对日志分析的查询语句需要消耗大量时间，可以使用主从或者分表的方式来隔离日志数据的插入和分析。
- 订单操作：必须支持事务，推荐选用InnoDB。


### **5.6 切换表的存储引擎**
- ALTER TABLE，按行将数据复制到新表，复制过程会占有大量IO，而且对原表上读锁。
- 导出导入：使用mysqldump导出数据表，修改dump文件中createtable语句中的存储引擎属性，然后删除原表再导入。会存在数据丢失问题。
- 创建与查询：创建新表，然后使用sql语句查询原表数据插入到新表。可以分批处理，为了保证数据一致可以对原表加锁。
