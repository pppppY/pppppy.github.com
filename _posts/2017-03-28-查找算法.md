---
layout: post
title:  "查找算法"
image: ''
description: ''

tags:
- 查找
categories:
- 算法
- 程序员的修养
---
查找是计算机数据处理中常用的一种重要运算，许多问题都能归结为查找问题。查找也被称为检索，目的是从按某种特定的数据结构存储的数据中检索出我们感兴趣的数据。**查找的方法与数据结构有很大的关系**，数据存储方式的不同对查找的性能影响巨大。本文将总结在常见数据结构中的查找算法，具体包括**线性表**、**树**和**Hash表**。

## **线性表上的查找**
线性表上的查找最朴素的应该是**顺序查找**，也就是遍历整个线性表来查找需要的元素。在有n个元素的线性表上，顺序查找的时间复杂度为O(n)，**对表中元素的顺序没有要求**。

还有一种著名的查找方法——**二分查找**，二分查找需要在**有序的线性表**上进行，它的时间复杂度为O(logn)。

二分查找每次取表中间位置的元素与查找目标进行比较：
- 如果相等，那么找到了目标元素。
- 如果中间元素大，说明目标元素只可能在中间元素之前。
- 否则，目标元素只可能在中间元素之后。

每一次比较都能去掉当前一半的元素，所以能保证查找的时间复杂度为O(logn)。二分查找的思想虽然很简单，但是实现起来有一些值得注意的小问题。许多算法题也都是基于二分查找设计的，因此在笔试和面试中经常被考到。计划写一篇”二分查找系列算法题解“的文章来总结常见的基于二分查找的题目。下面是二分查找的实现代码：
```java
public static int binSearch(int [] nums, int target){

    if(nums == null || nums.length == 0)
        return -1;

    int l = 0;
    int r = nums.length - 1;
    int mid;
    while(l <= r){
        mid = l + ((r - l) >> 1); // 注意(l + r)可能溢出
        if(nums[mid] < target){
            l = mid + 1;
        }else if(nums[mid] > target){
            r = mid - 1;
        }else {
            return mid;
        }
    }
    return -1;
}
```
## **树上的查找**
### **二叉搜索树**
二叉搜索树是一颗有如下性质的二叉树：
- 左子树所有节点key都小于根节点的key。
- 右子树所有节点key都大于跟节点的key。
- 左子树和右子树也是二叉搜索树。

中序遍历二叉搜索树就能按正序输出树中所有节点的key值。

二叉搜索树查找的期望时间复杂度为O(logn)，但是如果树非常的不平衡，极端情况下会退化成一个链表，那么查找的时间复杂度就为O(n)。

二叉搜索树的插入方法很简单，从根节点开始，比较待插入元素与当前根节点，大于就插入到右子树中，小于就插入到左子树中。
```java
public TreeNode insert(int key, int val){
    // 当前树不包含任何节点
    if(root == null){
        root = new TreeNode(key, val);
        return root;
    }

    // 沿着搜索树找到key对应的位置
    TreeNode nodeCurrent = root; // 当前子树的跟节点
    TreeNode nodeParent = null; // 当前子树的父节点
    while(nodeCurrent != null){
        if(nodeCurrent.key == key){
            return nodeCurrent;
        }
        nodeParent = nodeCurrent;
        if(nodeCurrent.key < key){
            nodeCurrent = nodeCurrent.right;
        }else{
            nodeCurrent = nodeCurrent.left;
        }
    }
    
    // 插入
    nodeCurrent = new TreeNode(key, val);
    if(nodeParent.key < key){
        nodeParent.right = nodeCurrent;
    }else{
        nodeParent.left = nodeCurrent;
    }
    return nodeCurrent;
}
```
二叉树的搜索就是从根节点开始，一直向下搜索。
```java
public TreeNode search(int key){
    TreeNode nodeCurrent = root;
    while(nodeCurrent != null){
        if(nodeCurrent.key < key){
            nodeCurrent = nodeCurrent.right;
        }else if(nodeCurrent.key > key){
            nodeCurrent = nodeCurrent.left;
        }else {
            return nodeCurrent;
        }
    }
    return null;
}
```
排序二叉树的删除分为三种情况：
1. 删除叶子节点，不会影响排序二叉树的结构。
2. 删除的节点只包含左子树/右子树，只需要将其左子树/右子树设置为被删除节点的左子树/右子树就可以了，如下图所示。

    ![img](http://img.blog.csdn.net/20130506115712159)
3. 删除的节点既有左子树又有右子树，可以找到待删除节点右子树的最小节点y，将y的父节点的左儿子指向y的右子树，然后用y替换待删除的节点，如下图所示。

    ![img](http://img.blog.csdn.net/20130506120027521)

### **平衡二叉搜索树**
前面已经提到过了，搜索二叉树是否平衡严重影响查找的性能。为了克服这个问题，出现了一些平衡二叉树，如AVL树，红黑树等。

**AVL树**

AVL树是一颗二叉搜索树，同时，所有节点的左子树和右子树的高度之差不大于1。通过加入这样的规定，使得AVL树永远都是基本平衡的，确保了插入、删除和查找时间复杂度稳定在O(logn)。

AVL树每个节点额外存储了一个平衡因子，它等于右子树的高度减去左子树的高度。显然，AVL树所有节点的平衡因子只能取-1,0,1。如果某个节点因为插入、删除等操作使得平衡因子<-1或>1，就需要通过一些旋转操作来重新使树到达平衡。详细介绍可以参见这篇[博客](http://dongxicheng.org/structure/avl/)。

**红黑树**

红黑树同样是自平衡搜索二叉树，Java中的TreeMap底层实现就采用了红黑树。红黑树主要有以下一些性质：
1. 节点是红色或黑色
2. 根是黑色
3. 所有叶子都是黑色（叶子是NIL节点）
4. 如果一个节点是红的，则它的两个儿子都是黑的
5. 从任一节点到其叶子的所有简单路径都包含相同数目的黑色节点。

通过这5条性质规定了，**红黑树最长的路径长度 <= 2 * 最短路径长度**。这是因为性质5规定了所有路径的黑色节点数目相同，所以最短的路径可能全是黑色。性质4规定了不能同时出现红色节点相连的情况，且性质2规定了根为黑色，所以一条路径上出现的红色节点数不可能大于黑色节点。

跟AVL树类似，节点的插入、删除等操作可能会影响红黑树的结构，必要是需要自底向上调整各节点，重新使树满足红黑树的要求，详细介绍可以参见这篇[博客](http://dongxicheng.org/structure/red-black-tree/)。


## **B-与B+树**
前面介绍的都是二叉搜索树，这些二叉搜索树适合于内部查找，它们适合组织较小的在内存中的索引。为什么说**二叉搜索树不适合用来组织存放在外存上的索引呢**？

我们假设每次访问树中一个节点就需要进行一次读文件的IO操作，如果使用二叉搜索树，每次查找需要进行O(logn)次读文件操作，显然需要耗费大量的时间。

所以，对于外部查找，一般使用k路搜索树来组织索引。

### **k路搜索树**
k路搜索树的节点结构为[j,p0,K1,p1,K2,...,kj,pj]，其中j <= k，表示当前节点有多少个子树，pi指向第i个子树，Ki表示记录的键。并且，pi子树包含的key一定大于ki，小于k(i+1)。我们可以看到，二叉搜索树其实是k路搜索树的特例，此时k=2。

与二叉搜索树类似，平衡的k路搜索树能提供更好的性能，常见的有B-/B+树。

**B-树**

是一种多路搜索树，它有如下的一些性质：
1. 任意非叶子结点最多只有k个儿子，其k>2；
2. 根结点的儿子数为[2, k]；
3. 除根结点以外的非叶子结点的儿子数为[k/2, k]；
4. 每个结点存放关键字个数为[(k + 1)/2-1, k-1]；
6. 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；
7. P[1]指向关键字<K[1]的子树，P[k]指向关键字大于K[k]的子树，其余P[i]指向关键字属于(K[i-1], K[i])的子树;
8. 所有叶子结点位于同一层；
比如一个3阶的B-树如下所示：

![](http://p.blog.csdn.net/images/p_blog_csdn_net/manesking/4.JPG)

B-树的查找时间与B-树的阶数k和高度h有关，不成功的查找时间取决于高度h，成功差找时间取决于key所在的层数。

向B-树插入元素key时，步骤如下：
1. 查找key
2. 如果树中不存在key，那么查找失败，最后必定失败于某个叶节点上。在该叶节点上插入key。
3. 插入之后，叶节点包含的键数量大于B-树的阶数时，需要分裂当前叶节点，并将key提升到当叶节点的父节点中去。
B-树插入之后，需要保持B-树的性质，所以可能采取分裂操作。具体例子如下图所示:
![imge](/images/b_insert.png)

**B+树**

B+树可以在叶子节点存储信息，是B-树的变形，它的性质跟B-树类似，但新添加了额外的特性：
1. 非叶子节点的子树个数和关键字相同，子树P[i]包含[K[i], K[i + 1])的所有关键字。
2. 所有关键字都在叶子节点出现，并且所有一个链表将每个叶子节点连起来。

![](http://p.blog.csdn.net/images/p_blog_csdn_net/manesking/5.JPG)

B+树**所有的关键字都出现在叶节点组成的链表中，并且是按序排列**。

在B+树中，每次查找都必须差到叶节点，才能得到关键字对应的数据（可能树的叶节点存储了访问数据的地址，也可能存储的就是数据本身）。

B+树是文件系统中常见的索引方式，比如MySQL数据库的聚簇索引就是基于B+树的。

## **散列查找**
Hash表通过一个Hash函数来计算关键字对应的hash码，然后通过这个hash码将关键字映射到一个线性表中，从而实现常数时间的查找。

但是，可能存在某些关键字的hash码相同，这时候就发生了Hash冲突，需要一些特殊的方法来解决Hash冲突问题。

Hash表中发生冲突的元素越多，查找的性能越差，极端情况，假设所有关键字都是同一个Hash码时，Hash查找将会退化为顺序查找。

Hash表最重要的两个内容就是：**Hash函数**和**Hash冲突的解决方法**。

**Hash函数**

Hash函数的实现方法有很多，比如除留取余法、数字分析法、折叠法和随机数法等等。这里给出一种常用的Hash方法BKDR hash：

```java
public static long hashBKDR(char[] chars){
    long hash = 0;
    for (char aChar : chars) {
        hash = hash * 131 + aChar; // 乘数可以是31,131,1313,13131
    }
    return hash;
}
```

**Hash冲突的解决方法**

常见的解决方法是拉链法和开放寻址法。

1. **拉链法**，拉链法就是将Hash码相同的元素用一个链表组织起来，Hash表存储的是链表的首元素。这种方法也是Java的HashMap采用的方法，但是在Java8中，Hash表存储的可能不是一个链表，而是一颗平衡二叉查找树（红黑树）。这样，当发生Hash冲突时，查找所有Hash码相同的关键字只需要O(logn)。

2. **开放寻址法**：使用开放寻址法的Hash表在插入和查找元素时，如果当前位置无法插入，将继续按一定规则遍历Hash表，直到找到某个可以插入的位置。
    
    遍历的规则有：线性探查法，二次探查法和双散列函数法。**使用线性和二次探查法容易出现堆积现象**。